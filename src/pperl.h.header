# -*- perl -*-
use strict;

package PPerlServer;

$PPERL::SOCKET_NAME = $ARGV[0];
$PPERL::MAX_SERVERS = $ARGV[1] || 3;
$PPERL::MAX_REQUESTS = $ARGV[2] || 100;
$PPERL::WIDE_OPEN = $ARGV[3] || 0;
$PPERL::DEBUG = 1;

BEGIN {
    *CORE::GLOBAL::exit = sub {
        my $retval = shift || 0;
        my $package = (caller)[0];
        if ($package eq 'PPerlServer') {
            exit($retval);
        }
        print ____RETCODE $retval;
        goto __PPerl_exit;
    };
}

use IO::Socket;
use IO::File;
use Fcntl ':flock';
use POSIX qw(:signal_h setsid WNOHANG);
use Carp 'croak','cluck';

use vars qw(%CHILDREN);
my ($pid,$pidfile,$saved_dir);

sub log_error {
#return;
  open(FH, ">>/tmp/pperl.log") || die "Can't open logfile: $!";
  print FH @_;
  close(FH);
}

sub init_server {
  ($pidfile) = @_;
  my $fh = open_pid_file($pidfile);
  become_daemon();
  log_error("became daemon with pid $$\n");
  print $fh $$;
  close $fh;
  return $pid = $$;
}

sub safe_fork {
  ### block signal for fork
  my $sigset = POSIX::SigSet->new(SIGINT);
  POSIX::sigprocmask(SIG_BLOCK, $sigset)
    or die "Can't block SIGINT for fork: [$!]\n";
  
  ### fork off a child
  my $pid = fork;
  unless( defined $pid ){
    die "Couldn't fork: [$!]\n";
  }

  ### make SIGINT kill us as it did before
  $SIG{INT} = 'DEFAULT';

  ### put back to normal
  POSIX::sigprocmask(SIG_UNBLOCK, $sigset)
    or die "Can't unblock SIGINT for fork: [$!]\n";

  return $pid;
}

sub become_daemon {
  my $child = fork;
  die "Can't fork: $!" unless defined($child);
  exit(0) if $child;    # parent dies;
  POSIX::setsid();     # become session leader
  open(STDIN,"</dev/null");
  open(STDOUT,">/dev/null");
  open(STDERR, '>&STDOUT');
  chdir '/';           # change working directory
  umask(0);            # forget file mode creation mask
  $ENV{PATH} = '/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin';
  delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};
  $SIG{CHLD} = \&reap_child;
  
  # signal handler for child die events
  $SIG{TERM} = $SIG{INT} = \&do_term;
  $SIG{HUP}  = \&do_hup;
}

sub launch_child {
  my $callback = shift;
  my $signals = POSIX::SigSet->new(SIGINT,SIGCHLD,SIGTERM,SIGHUP);
  sigprocmask(SIG_BLOCK,$signals);  # block inconvenient signals
  die("Can't fork: $!") unless defined (my $child = fork());
  # my $child = safe_fork();
  if ($child) {
    $CHILDREN{$child} = $callback || 1;
    $SIG{CHLD} = \&reap_child;
  }
  else {
    $SIG{HUP} = $SIG{INT} = $SIG{CHLD} = $SIG{TERM} = 'DEFAULT';
    $< = $>;  # set real UID to effective UID
  }
  sigprocmask(SIG_UNBLOCK,$signals);  # unblock signals
  return $child;
}

sub reap_child {
  log_error("reap_child\n");
  while ( (my $child = waitpid(-1,WNOHANG)) > 0) {
    $CHILDREN{$child}->($child) if ref $CHILDREN{$child} eq 'CODE';
    delete $CHILDREN{$child};
  }
  $SIG{CHLD} = \&sig_chld;
}

sub kill_children {
  log_error("Killing children: ", join(', ', keys(%CHILDREN)), "\n");
  kill INT => keys %CHILDREN;
  # wait until all the children die
  # sleep while %CHILDREN;
}

sub open_pid_file {
  my $file = shift;
  if (-e $file) {  # oops.  pid file already exists
    my $fh = IO::File->new($file) || return;
    my $pid = <$fh>;
    croak "Invalid PID file" unless $pid =~ /^(\d+)$/;
    croak "Server already running with PID $1" if kill 0 => $1;
    croak "Can't unlink PID file $file" unless -w $file && unlink $file;
  }
  return IO::File->new($file,O_WRONLY|O_CREAT|O_EXCL,($PPERL::WIDE_OPEN ? 0666 : 0644))
    or die "Can't create $file: $!\n";
}

END { 
  $> = $<;  # regain privileges
  unlink $pidfile if defined $pid and $$ == $pid;
}

my $CHILD_COUNT = 0;   # number of children
my $DONE        = 0;   # set flag to true when server done

# $SIG{INT} = $SIG{TERM} = sub { $DONE++ };

my $socket = IO::Socket::UNIX->new( Local     => $PPERL::SOCKET_NAME,
                                    Type      => SOCK_STREAM,
                                    Listen    => 1,
                                    Reuse     => 1,
                                  ) or die "Can't create listen socket: $!";

if ($PPERL::WIDE_OPEN) {
  chmod(0777, $PPERL::SOCKET_NAME);
}

# create PID file, initialize logging, and go into background
init_server("${PPERL::SOCKET_NAME}.pid");

sub cleanup_child {
  my $child = shift;
  $CHILD_COUNT--;
}

sub do_term {
  log_error("TERM signal received, terminating children...\n");
  close($socket);
  kill_children();
  exit(0);
}

sub do_hup {
  log_error("TERM signal received, terminating children...\n");
  close($socket);
  kill_children();
  exit(0);
}

while (!$DONE) {
  while ($CHILD_COUNT < $PPERL::MAX_SERVERS) {
    my $child = launch_child(\&cleanup_child);
    if ($child) {  # child > 0, so we're the parent
      log_error("launching child $child\n");
      $CHILD_COUNT++;
    }
    else {
      my $cycles = $PPERL::MAX_REQUESTS;
      while ($cycles--) {
        last unless my $____self = $socket->accept;
        warn "Child $$ handling connection\n" if $PPERL::DEBUG;
        
        # open stdin/stdout on $____self
        *STDIN  = \*{ $____self };
        *STDOUT = \*{ $____self };
        STDIN->autoflush(1);
        STDOUT->autoflush(1);
        select(STDOUT);
        
        my $____pid = $$;
        
        local %ENV = ();
        local @ARGV = ();
        
        PARTS:
        while (<STDIN>) {
            if (/^\[CWD\]$/) {
                my $cwd = <STDIN>;
                chomp $cwd;
                chdir $cwd or die "couldn't chdir: '$!'";
                next;
            }
            if (/^\[ENV\]$/) {
                my $env = <STDIN>;
                for (1..$env) {
                    local $/ = "\0";
                    local $_ = <STDIN>;
                    chomp;
                    my ($key, $value) = split(/\s*=\s*/, $_, 2);
                    $ENV{$key} = $value;
                }
                next;
            }
            if (/^\[ARGV\]$/) {
                my $args = <STDIN>;
                for (1..$args) {
                    local $/ = "\0";
                    local $_ = <STDIN>;
                    chomp;
                    log_error("Read arg: $_\n"); 
                    push @ARGV, $_;
                }
                next;
            }
            if (/^\[PID\]$/) {
                my $pid = <STDIN>;
                chomp($pid);
                $____pid = $pid;
                open(STDERR, ">${PPERL::SOCKET_NAME}.$pid.err");
                $SIG{__WARN__} = sub { print STDERR $_[0] };
                open(____RETCODE, ">${PPERL::SOCKET_NAME}.$pid.ret");
                next;
            }
            if (/^\[STDIO\]$/) {
                # warn "binding STDIO";
                last PARTS;
            }
            die "what's this then? '$_'";
        }
        
        local *ARGV unless @ARGV;

        if (!@ARGV) { # magic for <ARGV>
            # *ARGV = \*{ $____self };
            log_error("Set argv magic\n");
            open(ARGV, "<&STDIN");
            # @ARGV = ('-');
            # *ARGV = *STDIN;
        }
        
        print "OK\n";
        
        # reset bogus '<STDIN>, line 99' count
        $. = 0;
        # code goes in eval block here
        eval {
          package main;
          no strict;

