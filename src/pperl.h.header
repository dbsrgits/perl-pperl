# -*- perl -*-
use strict;

$PPERL::SOCKET_NAME = $ARGV[0];
$PPERL::MAX_SERVERS = $ARGV[1] || 3;

package PPerlServer;
use Net::Server::PreFork;

BEGIN {
    *CORE::GLOBAL::exit = sub {
        my $retval = shift || 0;
        print ____RETCODE $retval;
        goto __PPerl_exit;
    };
}

use vars qw(@ISA);
@ISA = qw(Net::Server::PreFork);

PPerlServer->run();
exit; # should never get here

sub configure_hook {
    my $self = shift;

    $self->{server}->{port}   = ["${PPERL::SOCKET_NAME}|unix"]; # port and addr to bind
    # $self->{server}->{chdir}  = '/';      # chdir to root
    # $self->{server}->{user}   = 'nobody'; # user to run as
    # $self->{server}->{group}  = 'nobody'; # group to run as
    $self->{server}->{min_servers} = $PPERL::MAX_SERVERS;
    $self->{server}->{setsid} = 1;        # daemonize
        $self->{server}->{pid_file} = "${PPERL::SOCKET_NAME}.pid";

    open(STDIN, '</dev/null') || die "Can't close STDIN [$!]";
    open(STDOUT,'>/dev/null') || die "Can't close STDOUT [$!]";
    open(STDERR, '>/dev/null') || die "Can't close STDERR [$!]";
    #  open(STDERR,'>&STDOUT')   || die "Can't close STDERR [$!]";
}

sub process_request {
    my $____self = shift;

    my $____pid = $$;

    local %ENV = ();
    local @ARGV = ();

    PARTS:
    while (<STDIN>) {
        if (/^\[CWD\]$/) {
            my $cwd = <STDIN>;
            chomp $cwd;
            chdir $cwd or die "couldn't chdir: '$!'";
            next;
        }
        if (/^\[ENV\]$/) {
            my $env = <STDIN>;
            for (1..$env) {
                local $/ = "\0";
                local $_ = <STDIN>;
                chomp;
                my ($key, $value) = split(/\s*=\s*/, $_, 2);
                $ENV{$key} = $value;
            }
            next;
        }
        if (/^\[ARGV\]$/) {
            my $args = <STDIN>;
            for (1..$args) {
                local $/ = "\0";
                local $_ = <STDIN>;
                chomp;
                push @ARGV, $_;
            }
            next;
        }
        if (/^\[PID\]$/) {
            my $pid = <STDIN>;
            chomp($pid);
            $____pid = $pid;
            open(STDERR, ">${PPERL::SOCKET_NAME}.$pid.err");
            open(____RETCODE, ">${PPERL::SOCKET_NAME}.$pid.ret");
            next;
        }
        if (/^\[STDIO\]$/) {
            # warn "binding STDIO";
            last PARTS;
        }
        die "what's this then? '$_'";
    }

    if (!@ARGV) { # magic for <ARGV>
        *ARGV = *STDIN;
    }

    print "OK\n";

    # reset bogus '<STDIN>, line 99' count
    $. = 0;
    # code goes in eval block here
    eval {
