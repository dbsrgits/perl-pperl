# -*- perl -*-
use strict;

package PPerlServer;

use PPerl qw( recv_fd writen close_fd read_byte read_int );
my $logfile = '/tmp/pperl.log';
PPerl::setlogfile($logfile);

$PPERL::SOCKET_NAME = $ARGV[0];
$PPERL::MAX_SERVERS = $ARGV[1] || 3;
$PPERL::MAX_REQUESTS = $ARGV[2] || 100;
$PPERL::WIDE_OPEN = $ARGV[3] || 0;
$PPERL::DEBUG = 1;

my $____self;

BEGIN {
    *CORE::GLOBAL::exit = sub {
        my $retval = shift || 0;
        my $package = (caller)[0];
        if ($package eq 'PPerlServer') {
            exit($retval);
        }
        writen($____self->fileno(),  $retval, length($retval));
        goto __PPerl_exit;
    };
}

use IO::Socket;
use IO::File;
use Fcntl ':flock', 'F_GETFL';
use POSIX qw(:signal_h setsid WNOHANG);
use Carp 'croak','cluck';

use vars qw(%CHILDREN);
my ($pid,$pidfile,$saved_dir);

sub log_error {
    return;
    open(FH, ">>$logfile")
      or die "Can't open logfile: '$logfile' $!";
    print FH @_;
    close(FH);
}

sub init_server {
  ($pidfile) = @_;
  my $fh = open_pid_file($pidfile);
  become_daemon();
  log_error("became daemon with pid $$\n");
  print $fh $$;
  close $fh;
  return $pid = $$;
}

sub safe_fork {
  ### block signal for fork
  my $sigset = POSIX::SigSet->new(SIGINT);
  POSIX::sigprocmask(SIG_BLOCK, $sigset)
    or die "Can't block SIGINT for fork: [$!]\n";

  ### fork off a child
  my $pid = fork;
  unless( defined $pid ){
    die "Couldn't fork: [$!]\n";
  }

  ### make SIGINT kill us as it did before
  $SIG{INT} = 'DEFAULT';

  ### put back to normal
  POSIX::sigprocmask(SIG_UNBLOCK, $sigset)
    or die "Can't unblock SIGINT for fork: [$!]\n";

  return $pid;
}

sub become_daemon {
  my $child = fork;
  die "Can't fork: $!" unless defined($child);
  exit(0) if $child;    # parent dies;
  POSIX::setsid();     # become session leader
  open(STDIN,"</dev/null");
  open(STDOUT,">/dev/null");
  open(STDERR, '>&STDOUT');
  chdir '/';           # change working directory
  umask(0);            # forget file mode creation mask
  $ENV{PATH} = '/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin';
  delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};
  $SIG{CHLD} = \&reap_child;

  # signal handler for child die events
  $SIG{TERM} = $SIG{INT} = \&do_term;
  $SIG{HUP}  = \&do_hup;
}

sub launch_child {
  my $callback = shift;
  my $signals = POSIX::SigSet->new(SIGINT,SIGCHLD,SIGTERM,SIGHUP);
  sigprocmask(SIG_BLOCK,$signals);  # block inconvenient signals
  die("Can't fork: $!") unless defined (my $child = fork());
  # my $child = safe_fork();
  if ($child) {
    $CHILDREN{$child} = $callback || 1;
    $SIG{CHLD} = \&reap_child;
  }
  else {
    $SIG{HUP} = $SIG{INT} = $SIG{CHLD} = $SIG{TERM} = 'DEFAULT';
    $< = $>;  # set real UID to effective UID
  }
  sigprocmask(SIG_UNBLOCK,$signals);  # unblock signals
  return $child;
}

sub reap_child {
  log_error("$$ reap_child\n");
  while ( (my $child = waitpid(-1,WNOHANG)) > 0) {
    log_error("$$ reaped $child\n");
    $CHILDREN{$child}->($child) if ref $CHILDREN{$child} eq 'CODE';
    delete $CHILDREN{$child};
  }
  $SIG{CHLD} = \&sig_chld;
}

sub kill_children {
  log_error("Killing children: ", join(', ', keys(%CHILDREN)), "\n");
  kill INT => keys %CHILDREN;
  # wait until all the children die
  # sleep while %CHILDREN;
}

sub open_pid_file {
  my $file = shift;
  if (-e $file) {  # oops.  pid file already exists
    my $fh = IO::File->new($file) || return;
    my $pid = <$fh>;
    croak "Invalid PID file" unless $pid =~ /^(\d+)$/;
    croak "Server already running with PID $1" if kill 0 => $1;
    croak "Can't unlink PID file $file" unless -w $file && unlink $file;
  }
  return IO::File->new($file,O_WRONLY|O_CREAT|O_EXCL,($PPERL::WIDE_OPEN ? 0666 : 0644))
    or die "Can't create $file: $!\n";
}

END {
  $> = $<;  # regain privileges
  unlink $pidfile if defined $pid and $$ == $pid;
}

my $CHILD_COUNT = 0;   # number of children
my $DONE        = 0;   # set flag to true when server done

# $SIG{INT} = $SIG{TERM} = sub { $DONE++ };

my $socket = IO::Socket::UNIX->new( Local     => $PPERL::SOCKET_NAME,
                                    Type      => SOCK_STREAM,
                                    Listen    => 1,
                                    Reuse     => 1,
                                  ) or die "Can't create listen socket: $!";

if ($PPERL::WIDE_OPEN) {
  chmod(0777, $PPERL::SOCKET_NAME);
}

# create PID file, initialize logging, and go into background
init_server("${PPERL::SOCKET_NAME}.pid");

sub cleanup_child {
  my $child = shift;
  $CHILD_COUNT--;
}

sub do_term {
  log_error("TERM signal received, terminating children...\n");
  close($socket);
  kill_children();
  exit(0);
}

sub do_hup {
  log_error("TERM signal received, terminating children...\n");
  close($socket);
  kill_children();
  exit(0);
}

sub read_line {
    my $sd = shift;
    my $num = $sd->fileno();
    my ($line);
    while (1) {
        my $new = read_byte($num);
        last if $new eq "\0";
        $line .= $new;
    }
    return $line;
}


sub setup_chunk {
    my $sd = shift;
    $sd->autoflush(1);

    log_error("$$ starting handshake\n");

    my $sock = $sd->fileno();
    log_error("$$ duping fds from $sock\n");

    my $target;
    while ((my $target = read_int($sock)) >= 0) {
        log_error("$$ targeting $target\n");
        if ( $target == $sock ) {
            log_error("$$ gor blimey Mary Poppins, he wants to be me\n");
            exit(1);
        }
        my $fd = recv_fd( $sock );
        if ($fd < 0) {
            log_error("$$ recv_fd for $target returned -1: $!\n");
            exit(1);
        }
        log_error("$$ $fd wants to be $target\n");

        my $ret = POSIX::dup2($fd, $target);
        log_error("$$ dup2 returns $ret\n");
        $ret = close_fd($fd);
        log_error("$$ close of $fd returns $ret\n");
    }


  PARTS:
    while ($_ = read_line($sd)) {
        if ($_ eq '[PID]') {
            my $pid = read_line($sd);
            log_error("$$ is talking to $pid\n");
            next;
        }
        if ($_ eq '[CWD]') {
            my $cwd = read_line($sd);
            log_error("$$ cwd $cwd\n");
            chdir $cwd or die "couldn't chdir: '$!'";
            next;
        }
        if ($_ eq '[ENV]') {
            log_error("$$ setting env\n");
            my $env = read_line($sd);
            for (1..$env) {
                local $_ = read_line($sd);
                chomp;
                my ($key, $value) = split(/\s*=\s*/, $_, 2);
                $ENV{$key} = $value;
            }
            next;
        }
        if ($_ eq '[ARGV]') {
            my $args = read_line($sd);
            log_error("$$ setting $args args\n");
            for (1..$args) {
                $_ = read_line($sd);
                log_error("$$ Read arg: $_\n");
                push @ARGV, $_;
            }
            next;
        }
        if ($_ eq '[DONE]') {
            last PARTS;
        }
        log_error("got unexpected '$_'\n");
        die "what's this then? '$_'";
    }
}

while (!$DONE) {
    while ($CHILD_COUNT < $PPERL::MAX_SERVERS) {
        my $child = launch_child(\&cleanup_child);
        if ($child) {  # child > 0, so we're the parent
            log_error("$$ launched child $child\n");
            $CHILD_COUNT++;
        }
        else {
            my $cycles = $PPERL::MAX_REQUESTS;
            while ($cycles--) {
                log_error("$$ waiting for new jobs\n");
                $____self = $socket->accept;
                unless ($____self) {
                    log_error("$$ accept failed: $!\n");
                    last;
                }
                my $____self_num = $____self->fileno;

                local %ENV  = ();
                local @ARGV = ();

                setup_chunk($____self);

                local *ARGV if !@ARGV; # mumble, grumble, scoping
                if (!@ARGV) { # magic for <ARGV>
                    # *ARGV = \*{ $____self };
                    log_error("$$ Set argv magic\n");
                    open(ARGV, "<&STDIN");
                    # @ARGV = ('-');
                    # *ARGV = *STDIN;
                }

                log_error("$$ sending OK message\n");
                writen($____self_num, "OK\n", 3);
                log_error("$$ sent\n");

                # reset bogus '<STDIN>, line 99' count
                $. = 0;
                # code goes in eval block here
                eval {
                    package main;
                    no strict;


